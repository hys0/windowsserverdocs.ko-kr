---
title: (
description: '에 대 한 Windows 명령을 항목 * * *- '
ms.custom: na
ms.prod: windows-server-threshold
ms.reviewer: na
ms.suite: na
ms.technology: manage-windows-commands
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 13a44bc3497b44d60bd4d351e389d493a50f1269
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2019
ms.locfileid: "59869464"
---
# <a name="for"></a>(



파일 집합에 각 파일에 대해 지정된 된 명령을 실행합니다.

이 명령을 사용하는 방법의 예는 [예](#BKMK_examples)를 참조하세요.

## <a name="syntax"></a>구문

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

## <a name="parameters"></a>매개 변수

|매개 변수|설명|
|---------|-----------|
|{%%\|%}\<Variable>|필수. 대체 가능 매개 변수를 나타냅니다. 단일 백분율 기호를 사용 하 여 (**%**)을 수행 하는 **에 대 한** 명령 프롬프트에서 명령을 합니다. 이중 백분율 기호를 사용 하 여 (**%%**)를 수행 하는 **에 대 한** 배치 파일 내 명령입니다. 변수는 대/소문자를 구분 하 고 나타내야 영문자 값와 같은 **%a**, **%b**, 또는 **%c**합니다.|
|(\<Set>)|필수. 하나 이상의 파일, 디렉터리 또는 텍스트 문자열 또는 명령을 실행 하는 데 기반이 값의 범위를 지정 합니다. 괄호가 필요 합니다.|
|\<명령 >|필수 사항입니다. 에 포함 된 값의 범위 또는 각 파일, 디렉터리 또는 텍스트 문자열에서 체크 아웃 수행 하려는 명령을 지정 *설정*합니다.|
|\<CommandLineOptions>|지정된 된 명령을 사용 하려면 명령줄 옵션을 지정 합니다.|
|/?|명령 프롬프트에 도움말을 표시합니다.|

## <a name="remarks"></a>설명

-   사용 하 여 **에 대 한**

    사용할 수는 **에 대 한** 명령 프롬프트에서 직접 또는 배치 파일 내에서 명령을 합니다.
-   일괄 처리 매개 변수를 사용 하 여

    다음 특성을 적용 합니다 **에 대 한** 명령:  
    -   합니다 **에 대 한** 대체 명령 **% * * * 변수* 또는 **% % * * * 변수* 파일을 모두 지정된 된 명령을 처리할 때까지 지정된 된 집합의 각 텍스트 문자열입니다.
    -   변수 이름은 대/소문자 구분, 글로벌 및 52 한 번에 수 있는 것 보다 더 이상있지 않습니다.
    -   일괄 처리 매개 변수를 사용 하 여 혼동을 피하기 위해 **%0** 통해 **9**, 에 대 한 모든 문자를 사용할 수 있습니다 *변수* 숫자 0-9 제외 하 고 있습니다. 간단한 배치 파일을 단일 문자 같은 **%%1** 작동 합니다.
    -   에 대 한 여러 값을 사용할 수 있습니다 *변수* 대체 가능한 다른 변수들을 구분 하기 위해 복잡 한 배치 파일에 있습니다.
-   파일 그룹을 지정합니다.

    합니다 *설정* 매개 변수 파일의 단일 그룹 또는 여러 파일 그룹을 나타낼 수 있습니다. 와일드 카드 문자를 사용할 수 있습니다 (**&#42;** 하 고 **?**) 설정 파일을 지정 합니다. 다음은 유효한 파일 집합입니다.  
    ```
    (*.doc) 
    (*.doc *.txt *.me)
    (jan*.doc jan*.rpt feb*.doc feb*.rpt)
    (ar??1991.* ap??1991.*)
    ```  
    사용 하는 경우는 **에 대 한** 명령, 첫 번째 값 *설정* 대체 **% * * * 변수* 또는 **% % * * * 변수*, 이면 지정 된 및 이 값을 처리 하는 명령입니다. 모든 파일 (또는 파일 그룹)에 해당 하는 때까지 계속는 *설정* 값 처리 됩니다.
-   사용 하는 **에** 하 고 **수행** 키워드

    **** 하 고 **수행** 매개 변수가 있지만 사용 하 여 사용 해야 **에 대 한**합니다. 이러한 키워드를 생략 하면 오류 메시지가 나타납니다.
-   또 다른 형태의 사용 하 여 **에 대 한**

    명령 확장 (즉, 기본값)를 사용 하는 경우 다음과 같은 추가 형태의 **에 대 한** 지원 됩니다.  
    -   디렉터리에만

        경우 *설정* 와일드 카드 문자가 포함 되어 있습니다 (**&#42;** 하거나 **?**), 지정 된 *명령* 집합 (대신 각 디렉터리에 대 한 실행 지정된 된 디렉터리의 파일)과 일치 하는 *설정*합니다.

        구문은 다음과 같습니다.  
        ```
        for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
        ```  
    -   Recursive

        시작 하는 디렉터리 트리 *드라이브*:*경로* 하 고 실행 합니다 **에 대 한** 트리의 각 디렉터리에 문의 합니다. 디렉터리가 없는 지정 되 면 **/r**, 현재 디렉터리를 루트 디렉터리로 사용 됩니다. 경우 *설정* 단일 마침표 (.)만 디렉터리 트리만 열거 합니다.

        구문은 다음과 같습니다.  
        ```
        for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        ```  
    -   값의 범위를 반복합니다.

        반복 변수를 사용 하 여 시작 값을 설정 (*시작*#) 및 집합 범위의 값 집합의 종료 값이 초과 될 때까지 값을 통해 다음 단계 (*끝*#). **/l** 비교 하 여 반복 되는 실행 *시작*와 # *끝*#입니다. 경우 *시작*#은 보다 작은 *끝*# 명령을 실행 합니다. 반복 변수를 초과할 때 *끝*#, 명령 셸 루프를 종료 합니다. 음수를 사용할 수도 있습니다 *단계*# 감소 하는 값의 범위를 단계별로 실행 되도록 합니다. 예를 들어, (1,1,5) 1 2 3 4 5 시퀀스를 생성 하 고 (5,-1, 1) 5 4 3 2 1 시퀀스를 생성 합니다.

        구문은 다음과 같습니다.  
        ```
        for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
        ```  
    -   반복 및 파일 구문 분석

        프로세스 명령 출력, 문자열 및 파일 콘텐츠를 구문 분석 하는 파일을 사용 합니다.  반복 변수를 사용 하 여 내용이 나 검사 하려는 문자열을 정의 하 고 사용 하 여 다양 한 *ParsingKeywords* 추가 구문 분석을 수정 하는 옵션입니다.  사용 된 *ParsingKeywords* 토큰 지정 반복 변수는 토큰을 전달 해야 하는 옵션입니다. 토큰 옵션 없이 사용할 경우 사용자에 게 유의 **/f** 만 첫 번째 토큰 살펴봅니다.

        파일 구문 분석 하는 작업은 출력, 문자열 또는 파일 내용을 읽는 다음 텍스트의 개별 선으로 분할 하 고 0 개 이상의 토큰으로 구문 분석 되는 각 줄의 구성 됩니다. **에 대 한** 루프 반복 변수 값이 토큰에 설정 된 후 호출 됩니다. 기본적으로 **/f** 각 파일의 각 줄에서 분리 하 고 첫 번째 빈 토큰을 전달 합니다. 빈 줄은 건너뜁니다.

        구문은 다음과 같습니다.  
        ```
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ("<LiteralString>") do <Command> [<CommandLineOptions>]
        for /f ["<ParsingKeywords>"] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
        ```  
        *설정* 인수에는 하나 이상의 파일 이름을 지정 합니다. 각 파일은 열, 읽기 및 처리에 있는 다음 파일을 이동 하기 전에 *설정*합니다. 기본 구문 분석 동작을 재정의 하려면 지정 *ParsingKeywords*합니다. 이것이 다른 구문 분석 옵션을 지정 하려면 하나 이상의 키워드를 포함 하는 따옴표 붙은 문자열입니다.

        사용 하는 경우는 **usebackq** 옵션을 다음 구문 중 하나를 사용 합니다.  
        ```
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ("<Set>") do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
        for /f ["usebackq <ParsingKeywords>"] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
        ```  
        다음 표에서 구문 분석에 사용할 수 있는 키워드를 보여 줍니다. *ParsingKeywords*합니다.  
        |키워드|설명|
        |-------|-----------|
        |eol=\<c>|한 줄의 끝 문자 (하나의 문자)를 지정합니다.|
        |skip=\<N>|파일의 시작 부분에 표시 하지 않으려면 줄 수를 지정 합니다.|
        |delims=\<xxx>|구분 기호 집합을 지정합니다. 이 작업 공간 및 탭의 기본 구분 기호 집합을 대체 합니다.|
        |토큰 =\<X, Y, M – N >|전달 되는 각 줄의 토큰을 지정 된 **에 대 한** 각 반복에 대 한 루프입니다. 결과적으로, 추가 변수 이름이 할당 됩니다. *M*–*N* 에서 범위를 지정 합니다.는 *M*번째부터 *N*번째 토큰입니다. 하는 경우의 마지막 문자는 **토큰 =** 문자열은 별표 (**&#42;**), 추가 변수 할당 되 고 구문 분석 된 마지막 토큰 뒤의 나머지 텍스트 줄에 받을 합니다.|
        |usebackq|지정 합니다: 백 따옴표 붙은 문자열 명령으로 실행, 작은따옴표로 묶인 문자열 리터럴 문자열로 사용 하거나 긴 파일 이름에 공백이 포함 된 파일 이름에 허용  *\<설정\>* 를 각 묶어야 큰따옴표입니다.|
    -   변수 대체

        다음 표에서 선택적 구문을 나열 (모든 변수에 **있습니까**).  
        |한정자를 사용 하 여 변수|설명|
        |----------------------|-----------|
        |% ~ I|확장 **%i** 따옴표를 제거 ("").|
        |% ~ fI|확장 **%i** 정규화 된 경로 이름입니다.|
        |% ~ dI|확장 **%i** 드라이브 문자로 합니다.|
        |% ~ pI|확장 **%i** 만 경로에 있습니다.|
        |% ~ nI|확장 **%i** 만 파일 이름으로 저장 합니다.|
        |% ~ xI|확장 **%i** 파일 이름 확장명으로 합니다.|
        |% ~ sI|짧은 이름만 포함에 대 한 경로 확장 합니다.|
        |% ~ aI|확장 **%i** 파일의 파일 특성입니다.|
        |% ~ tI|확장 **%i** 파일의 시간과 날짜를 합니다.|
        |% ~ zI|확장 **%i** 파일의 크기입니다.|
        |% ~ $PATH: I|PATH 환경 변수에 나열 된 디렉터리를 검색 하 고 확장 **%i** 찾을 첫 번째 디렉터리의 정규화 된 이름에 있습니다. 환경 변수 이름이 정의 되지 않은 경우 파일은 검색에서 찾을 수 없습니다이 한정자는 빈 문자열로 확장 됩니다.|

        다음 표에서 복합 결과 얻는 데 사용할 수 있는 한정자 조합을 나열 합니다.  
        |결합 된 한정자가 포함 된 변수|설명|
        |--------------------------------|-----------|
        |% ~ dpI|확장 **%i** 드라이브 문자와 경로를 합니다.|
        |% ~ nxI|확장 **%i** 파일 이름과 확장명 전용입니다.|
        |% ~ fsI|확장 **%i** 짧은 이름의 전체 경로 이름입니다.|
        |% ~ dp$ 경로: I|에 대 한 PATH 환경 변수에 나열 된 디렉터리를 검색 **%i** 드라이브 문자와 찾은 첫 번째의 경로를 확장 합니다.|
        |% ~ ftzaI|확장 **%i** 유사한 출력 줄에 **dir**합니다.|

        위 예제에서 대체할 수 있습니다 **%i** 및 다른 유효한 값을 가진 경로입니다. 유효한 **에 대 한** 변수 이름 종료는 **%~** 구문입니다.

        예: 변수 이름은 대문자를 사용 하 여 **%i**, 코드를 더 읽기 쉽게 하 고 대 소문자를 구분 하지 않은 한정자와 혼동 되지 않도록 합니다.
-   문자열을 구문 분석

    사용할 수는 **/f에 대 한** 래핑하여 논리는 즉시 문자열을 구문 분석 *\<LiteralString\>* 하나로: 큰따옴표 (*없이* " usebackq") 또는 따옴표 (*사용 하 여* "usebackq")-예를 들어 ("MyString") 또는 ('MyString'). *\<LiteralString\>*  파일에서 입력 되는 한 줄으로 처리 됩니다. 구문 분석할 때 *\<LiteralString\>* 이중 따옴표로 기호 명령 (같은 **\\ \& \| \> \< \^**) 일반 문자로 처리 됩니다.
-   출력을 구문 분석

    사용할 수는 **/f에 대 한** 백 따옴표 붙은 배치 하 여 명령의 출력을 구문 분석 하는 명령 *\<명령\>* 괄호 사이입니다. 하위 Cmd.exe에 전달 되는 명령줄으로 처리 됩니다. 출력은 메모리에 캡처되고 파일 처럼 구문 분석 합니다.

## <a name="BKMK_examples"></a>예제

사용 하 여 **에 대 한** 배치 파일에서 다음 구문을 사용 합니다.
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
대체할 수 있는 변수를 사용 하 여 확장명이.doc 또는.txt 있는 현재 디렉터리에 있는 모든 파일의 내용을 표시 하려면 **%f**, 유형:
```
for %f in (*.doc *.txt) do type %f 
```
위의 예제에서는 확장명이.doc 또는.txt 현재 디렉터리에 있는 각 파일에 대 한 대체는 **%f** 모든 파일의 내용이 표시 될 때까지 변수입니다. 배치 파일에서이 명령을 사용 하려면 모든 일치 항목을 바꾸려면 **%f** 와 **%%1**합니다. 그렇지 않으면 변수는 무시 하 고 오류 메시지가 표시 됩니다.

파일을 구문 분석 하려면 무시 하 고 주석 처리 된 줄, 유형:
```
for /f "eol=; tokens=2,3* delims=," %i in (myfile.txt) do @echo %i %j %k
```
이 명령은 Myfile.txt의 각 줄을 구문 분석합니다. 세미콜론으로 시작 하는 줄을 무시 하 고 각 줄을에서 두 번째 및 세 번째 토큰을 전달 된 **에 대 한** 본문 (토큰은 쉼표 또는 공백을로 구분 됨). 본문은 **에 대 한** 문 참조 **%i** 토큰을 가져오기 위해 두 번째, **%j** 세 번째 토큰을 가져오려면 및 **%k** 모든 나머지 토큰을 가져오려면. 사용자가 제공 하는 파일 이름에 공백이 있으면 (예를 들어 "파일 이름") 텍스트 주위에 따옴표를 사용 합니다. 인용 부호를 사용 하려면 사용 해야 **usebackq**합니다. 그렇지 않으면 따옴표는 리터럴 문자열을 구문 분석을 정의로 해석 됩니다.

**%i** 에 명시적으로 선언 되는 **에 대 한** 문입니다. **%j** 및 **%k** 를 사용 하 여 암시적으로 선언 된 **토큰 =** 합니다. 사용할 수 있습니다 **토큰 =** 문자 "z" 또는 "Z." 보다 큰 변수를 선언 하려고 하면 발생 하지는 26 개 토큰을 지정 하려면

다음 예제에서는 현재 환경에서 환경 변수 이름을 열거합니다. 배치 하 여 명령의 출력을 구문 분석을 *설정* 는 괄호를 입력 합니다.
```
for /f "usebackq delims==" %i in ('set') do @echo %i 
```

#### <a name="additional-references"></a>추가 참조

[명령줄 구문 키](command-line-syntax-key.md)
