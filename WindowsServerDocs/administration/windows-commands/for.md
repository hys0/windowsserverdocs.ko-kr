---
title: '-'
description: 파일 집합 내에서 각 파일에 대해 지정 된 명령을 실행 하는 for 명령에 대 한 참조 항목입니다.
ms.prod: windows-server
ms.technology: manage-windows-commands
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 24ef5bc159e67862d419bd2728b14585f8b095d4
ms.sourcegitcommit: bf887504703337f8ad685d778124f65fe8c3dc13
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/16/2020
ms.locfileid: "83437018"
---
# <a name="for"></a>-

파일 집합 내에서 각 파일에 대해 지정 된 명령을 실행 합니다.

## <a name="syntax"></a>구문

```
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
```

### <a name="parameters"></a>매개 변수

| 매개 변수 | 설명 |
| --------- | ----------- |
| `{%% | %}<variable>` | 필수 요소. 대체 가능 매개 변수를 나타냅니다. 단일 백분율 기호 ()를 사용 `%` 하 여 명령 프롬프트에서 **for** 명령을 수행 합니다. 이중 백분율 기호를 사용 하 여 (`%%`)를 수행 하는 **에 대 한** 배치 파일 내 명령입니다. 변수는 대/소문자를 구분 하며, **% a**, **% b**또는 **% c**와 같은 영문자 값으로 표시 되어야 합니다. |
| (`<set>`) | 필수 사항입니다. 하나 이상의 파일, 디렉터리 또는 텍스트 문자열 또는 명령을 실행 하는 데 기반이 값의 범위를 지정 합니다. 괄호가 필요합니다. |
| `<command>` | 필수 사항입니다. 각 파일, 디렉터리 또는 텍스트 문자열이 나 *설정*에 포함 된 값 범위에서 수행할 명령을 지정 합니다. |
| `<commandlineoptions>` | 지정된 된 명령을 사용 하려면 명령줄 옵션을 지정 합니다. |
| /? | 명령 프롬프트에 도움말을 표시합니다. |

#### <a name="remarks"></a>설명

- 배치 파일 내에서 또는 명령 프롬프트에서 직접이 명령을 사용할 수 있습니다.

- **For** 명령에 적용 되는 특성은 다음과 같습니다.

  - 이 명령은 `% variable` 지정 된 `%% variable` 명령이 모든 파일을 처리할 때까지 또는를 지정 된 집합의 각 텍스트 문자열로 바꿉니다.

  - 변수 이름은 대/소문자 구분, 글로벌 및 52 한 번에 수 있는 것 보다 더 이상있지 않습니다.

  - 일괄 처리 매개 변수와 혼동 하지 않도록 하려면 `%0` `%9` 숫자 **0** ~ **9**를 제외 하 고 *변수* 에 모든 문자를 사용할 수 있습니다. 간단한 배치 파일의 경우와 같은 단일 문자는 `%%f` 작동 합니다.

  - 복합 배치 파일에서 *변수에* 여러 값을 사용 하 여 대체 가능한 변수를 구분할 수 있습니다.

- *Set* 매개 변수는 단일 파일 그룹 또는 여러 파일 그룹을 나타낼 수 있습니다. 와일드 카드 문자 (**&#42;** 및 **?**)를 사용 하 여 파일 집합을 지정할 수 있습니다. 다음은 유효한 파일 집합입니다.

  ```
  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```

- 이 명령을 사용 하는 경우 *set* 의 첫 번째 값이 `% variable` 또는 `%% variable` 를 바꾸고 지정 된 명령이이 값을 처리 합니다. 이는 *설정* 된 값에 해당 하는 모든 파일 (또는 파일 그룹)이 처리 될 때까지 계속 됩니다.

- 및 **은** 매개 **변수가 아니지만** 이 명령과 함께 사용 해야 합니다. 이러한 키워드를 생략 하면 오류 메시지가 나타납니다.

- 명령 확장을 사용 하는 경우 (기본값) **에 대해** 다음과 같은 추가 형식이 지원 됩니다.

  - **디렉터리만:** *Set* 에 와일드 카드 문자 (**&#42;** 또는 **?**)가 포함 된 경우 지정 된 *명령은* *set*와 일치 하는 지정 된 디렉터리에 있는 파일 집합이 아닌 각 디렉터리에 대해 실행 됩니다. 구문은 다음과 같습니다.

    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```

  - **재귀:** *드라이브*:*경로* 를 기반으로 하는 디렉터리 트리를 탐색 하 고 트리의 각 디렉터리에서 **for** 문을 실행 합니다. 디렉터리가 없는 지정 되 면 **/r**, 현재 디렉터리를 루트 디렉터리로 사용 됩니다. *Set* 이 단일 마침표 (.) 인 경우에만 디렉터리 트리를 열거 합니다. 구문은 다음과 같습니다.

    ```
    for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    ```

  - **값의 범위 반복:** 반복 변수를 사용 하 여 시작 값을 설정 (*start*#) 한 다음 값이 설정 된 끝 값 (*end*#)을 초과할 때까지 값의 집합을 단계별로 실행 합니다. **/l** 은 *start*#과 *end*#을 비교 하 여 반복을 실행 합니다. *Start*#가 *end*# 보다 작은 경우 명령이 실행 됩니다. 반복 변수가 *end*#을 초과 하면 명령 셸은 루프를 종료 합니다. 음수 *단계*#을 사용 하 여 값을 줄이면 범위를 단계별로 진행할 수도 있습니다. 예를 들어, (1,1,5) 1 2 3 4 5 시퀀스를 생성 하 고 (5,-1, 1) 5 4 3 2 1 시퀀스를 생성 합니다. 구문은 다음과 같습니다.

    ```
    for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
    ```

  - **반복 및 파일 구문 분석:** 파일 구문 분석을 사용 하 여 명령 출력, 문자열 및 파일 콘텐츠를 처리 합니다. 반복 변수를 사용 하 여 검사할 내용 또는 문자열을 정의 하 고 다양 한 *parsingkeywords* 옵션을 사용 하 여 구문 분석을 추가로 수정 합니다.  *Parsingkeywords* token 옵션을 사용 하 여 반복 변수로 전달 해야 하는 토큰을 지정할 수 있습니다. 토큰 옵션 없이 사용할 경우 사용자에 게 유의 **/f** 만 첫 번째 토큰 살펴봅니다.

    파일 구문 분석 하는 작업은 출력, 문자열 또는 파일 내용을 읽는 다음 텍스트의 개별 선으로 분할 하 고 0 개 이상의 토큰으로 구문 분석 되는 각 줄의 구성 됩니다. **에 대 한** 루프 반복 변수 값이 토큰에 설정 된 후 호출 됩니다. 기본적으로 **/f** 각 파일의 각 줄에서 분리 하 고 첫 번째 빈 토큰을 전달 합니다. 빈 줄은 건너뜁니다.

    구문은 다음과 같습니다.

    ```
    for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in ('<command>') do <command> [<commandlinepptions>]
    ```

    *Set* 인수는 하나 이상의 파일 이름을 지정 합니다. *Set*의 다음 파일로 이동 하기 전에 각 파일을 열고 읽고 처리 합니다. 기본 구문 분석 동작을 재정의 하려면 *parsingkeywords*를 지정 합니다. 이것이 다른 구문 분석 옵션을 지정 하려면 하나 이상의 키워드를 포함 하는 따옴표 붙은 문자열입니다.

    사용 하는 경우는 **usebackq** 옵션을 다음 구문 중 하나를 사용 합니다.

    ```
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in ('<LiteralString>') do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (`<command>`) do <command> [<commandlinepptions>]
    ```

    다음 표에서는 *parsingkeywords*에 사용할 수 있는 구문 분석 키워드를 보여 줍니다.

    | 키워드 | 설명 |
    | ------- | ----------- |
    | eol =`<c>` | 한 줄의 끝 문자 (하나의 문자)를 지정합니다. |
    | skip =`<n>` | 파일의 시작 부분에 표시 하지 않으려면 줄 수를 지정 합니다. |
    | delims =`<xxx>` | 구분 기호 집합을 지정합니다. 이 작업 공간 및 탭의 기본 구분 기호 집합을 대체 합니다. |
    | 토큰 =`<x,y,m–n>` | 전달 되는 각 줄의 토큰을 지정 된 **에 대 한** 각 반복에 대 한 루프입니다. 결과적으로, 추가 변수 이름이 할당 됩니다. *m-n* 은 *m*부터 *n*번째 토큰까지 범위를 지정 합니다. Token **=** string의 마지막 문자가 별표 (**&#42;**) 이면 추가 변수가 할당 되 고 구문 분석 된 마지막 토큰 뒤의 줄에서 나머지 텍스트를 받습니다. |
    | usebackq | 뒤로 따옴표 붙은 문자열을 명령으로 실행 하거나, 작은따옴표로 묶은 단일 문자열을 리터럴 문자열로 사용 하거나, 공백을 포함 하는 긴 파일 이름에 대해 각를 큰따옴표로 묶을 수 있도록 지정 합니다 `<set>` . |

  - **변수 대체:** 다음 표에서는 선택적 구문을 나열 합니다 (모든 변수 **I**).

    | 한정자를 사용 하 여 변수 | 설명 |
    | ---------------------- | ----------- |
    |` %~I` | 확장 `%I` 하 여 주변의 따옴표를 제거 합니다. |
    | `%~fI `| `%I`는 정규화 된 경로 이름으로 확장 됩니다. |
    | `%~dI `| `%I`드라이브 문자로만 확장 합니다. |
    | `%~pI` | `%I`경로만 확장 합니다. |
    | `%~nI `| `%I`파일 이름만 확장 합니다. |
    | `%~xI` | `%I`확장명은 파일 이름 확장명 으로만 확장 됩니다. |
    | `%~sI` | 짧은 이름만 포함에 대 한 경로 확장 합니다. |
    | `%~aI` | `%I`파일의 파일 특성으로 확장 됩니다. |
    | `%~tI` | `%I`파일의 날짜 및 시간으로 확장 됩니다. |
    | `%~zI` | `%I`파일 크기를 확장 합니다. |
    | `%~$PATH:I` | PATH 환경 변수에 나열 된 디렉터리를 검색 하 고 `%I` 찾은 첫 번째 디렉터리의 정규화 된 이름으로 확장 합니다. 환경 변수 이름이 정의 되지 않은 경우 파일은 검색에서 찾을 수 없습니다이 한정자는 빈 문자열로 확장 됩니다. |

    다음 표에서 복합 결과 얻는 데 사용할 수 있는 한정자 조합을 나열 합니다.

    | 결합 된 한정자가 포함 된 변수 | 설명 |
    | -------------------------------- | ----------- |
    | `%~dpI `| `%I`드라이브 문자 및 경로만 확장 합니다. |
    | `%~nxI` | `%I`는 파일 이름 및 확장명 으로만 확장 됩니다. |
    | `%~fsI` | `%I`는 짧은 이름만 사용 하 여 전체 경로 이름으로 확장 됩니다. |
    | `%~dp$PATH:I` | 에 대 한 PATH 환경 변수에 나열 된 디렉터리를 검색 하 `%I` 고 첫 번째 드라이브의 드라이브 문자 및 경로로 확장 합니다. |
    | `%~ftzaI` | `%I` **Dir**과 같은 출력 줄로 확장 됩니다. |

    위의 예제에서 `%I` 및 PATH를 다른 유효한 값으로 바꿀 수 있습니다. **유효한 변수** 이름은 **%~** 구문을 끝냅니다.

    와 같은 대문자 변수 이름을 사용 하 여 `%I` 코드를 보다 읽기 쉽게 만들고 대/소문자를 구분 하지 않는 한정자의 혼동을 방지할 수 있습니다.

- **문자열 구문 분석:** `for /f` `<literalstring>` 큰따옴표 (usebackq*제외* ) 또는 작은따옴표 (usebackq) (예: (mystring) 또는 (' mystring '))로*with* 래핑하여 구문 분석 논리를 직접 문자열에 사용할 수 있습니다. `<literalstring>`는 파일에서 한 줄의 입력으로 처리 됩니다. 큰따옴표로 구문 분석 `<literalstring>` 하는 경우 명령 기호 (예:, `\ & | > < ^` )는 일반 문자로 처리 됩니다.

- **출력 구문 분석:** 명령을 사용 하 여 `for /f` 괄호 사이에 백슬래시를 추가 하 여 명령의 출력을 구문 분석할 수 있습니다 `<command>` . 하위 Cmd.exe에 전달 되는 명령줄으로 처리 됩니다. 출력은 메모리에 캡처되고 파일 처럼 구문 분석 합니다.

## <a name="examples"></a>예

사용 하 여 **에 대 한** 배치 파일에서 다음 구문을 사용 합니다.

```
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
```

대체할 수 있는 변수를 사용 하 여 확장명이.doc 또는.txt 있는 현재 디렉터리에 있는 모든 파일의 내용을 표시 하려면 **%f**, 유형:

```
for %f in (*.doc *.txt) do type %f
```

위의 예제에서는 확장명이.doc 또는.txt 현재 디렉터리에 있는 각 파일에 대 한 대체는 **%f** 모든 파일의 내용이 표시 될 때까지 변수입니다. 배치 파일에서이 명령을 사용 하려면 모든 일치 항목을 바꾸려면 **%f** 와 **%%1**합니다. 그렇지 않으면 변수는 무시 하 고 오류 메시지가 표시 됩니다.

파일을 구문 분석 하려면 무시 하 고 주석 처리 된 줄, 유형:

```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```

이 명령은 *myfile*의 각 줄을 구문 분석 합니다. 세미콜론으로 시작 하는 줄을 무시 하 고 각 줄을에서 두 번째 및 세 번째 토큰을 전달 된 **에 대 한** 본문 (토큰은 쉼표 또는 공백을로 구분 됨). 본문은 **에 대 한** 문 참조 **%i** 토큰을 가져오기 위해 두 번째, **%j** 세 번째 토큰을 가져오려면 및 **%k** 모든 나머지 토큰을 가져오려면. 사용자가 제공 하는 파일 이름에 공백이 포함 된 경우 텍스트에 따옴표를 사용 합니다 (예: 파일 이름). 인용 부호를 사용 하려면 사용 해야 **usebackq**합니다. 그렇지 않으면 따옴표는 리터럴 문자열을 구문 분석을 정의로 해석 됩니다.

**%i** 에 명시적으로 선언 되는 **에 대 한** 문입니다. **%j** 및 **%k** 를 사용 하 여 암시적으로 선언 된 **토큰 =** 합니다. 문자 z 또는 Z 보다 큰 변수를 선언 하려고 시도 하지 않는 경우 token **=** 를 사용 하 여 최대 26 개의 토큰을 지정할 수 있습니다.

괄호 사이에 *집합* 을 배치 하 여 명령의 출력을 구문 분석 하려면 다음을 입력 합니다.

```
for /f usebackq delims== %i in ('set') do @echo %i
```

## <a name="additional-references"></a>추가 참조

- [명령줄 구문 키](command-line-syntax-key.md)
