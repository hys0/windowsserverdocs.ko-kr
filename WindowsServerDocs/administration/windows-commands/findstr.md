---
title: findstr
description: 파일에서 텍스트의 패턴을 검색 하는 findstr 명령에 대 한 참조 항목입니다.
ms.prod: windows-server
ms.technology: manage-windows-commands
ms.topic: article
ms.assetid: c2d803fb-4cd2-46a1-a1b7-6f5e0249c418
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 7f8d353b6d3aee77960b208d89372aee5dca07e3
ms.sourcegitcommit: bf887504703337f8ad685d778124f65fe8c3dc13
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/16/2020
ms.locfileid: "83436119"
---
# <a name="findstr"></a>findstr

파일에서 텍스트의 패턴을 검색 합니다.

## <a name="syntax"></a>구문

```
findstr [/b] [/e] [/l | /r] [/s] [/i] [/x] [/v] [/n] [/m] [/o] [/p] [/f:<file>] [/c:<string>] [/g:<file>] [/d:<dirlist>] [/a:<colorattribute>] [/off[line]] <strings> [<drive>:][<path>]<filename>[ ...]
```

### <a name="parameters"></a>매개 변수

| 매개 변수 | 설명 |
| --------- | ----------- |
| /b | 줄의 시작 부분에는 텍스트 패턴을 일치 합니다. |
| /e | 줄의 끝에 있으면 텍스트 패턴을 찾습니다. |
| /l | 프로세스는 문자 그대로 문자열을 검색 합니다. |
| /r | 프로세스 검색 문자열을 정규식으로 사용 합니다. 이 값은 기본 설정입니다. |
| /s | 현재 디렉터리와 모든 하위 디렉터리를 검색합니다. |
| /i | 문자열을 검색할 때는 문자의 대/소문자를 무시 합니다. |
| /x | 정확히 일치 하는 줄을 표시 합니다. |
| /v | 일치 항목을 포함 하지 않는 줄만 인쇄 합니다. |
| /n | 일치 하는 각 줄의 줄 번호를 인쇄 합니다. |
| /m | 파일에는 일치 하는 항목을 포함 하는 경우 파일 이름만을 출력 합니다. |
| /o | 일치 하는 각 줄 앞에 문자 오프셋을 표시 합니다. |
| /p | 인쇄할 수 없는 문자를 사용 하 여 파일을 건너뜁니다. |
| 설정 / 해제 [line] | 오프 라인 특성 집합이 있는 파일을 건너뛰지 않습니다. |
| /f`<file>` | 지정된 된 파일에서 파일 목록을 가져옵니다. |
| /c`<string>` | 지정된 된 텍스트를 사용 하 여 리터럴 검색 문자열입니다. |
| /g`<file>` | 지정된 된 파일에서 문자열을 검색 하는 가져옵니다. |
| d`<dirlist>` | 지정된 된 디렉터리 목록을 검색합니다. 예를 들어 각 디렉터리는 세미콜론 (;)으로 구분 해야 `dir1;dir2;dir3`합니다. |
| 없음을`<colorattribute>` | 두 개의 16 진수가 color 특성을 지정합니다. 형식 `color /?` 추가 정보에 대 한 합니다. |
| `<strings>` | *파일 이름*에서 검색할 텍스트를 지정 합니다. 필수 사항입니다. |
| `[\<drive>:][<path>]<filename>[ ...]` | 검색할 파일 및 파일 또는 위치를 지정 합니다. 하나 이상의 파일에 이름이 필요 합니다. |
| /? | 명령 프롬프트에 도움말을 표시합니다. |

#### <a name="remarks"></a>설명

- 모든 **findstr** 명령줄 옵션은 명령 문자열에서 *문자열* 및 *파일 이름* 앞에와 야 합니다.

- 정규식은 리터럴 문자와 meta 문자를 모두 사용 하 여 정확한 문자열 대신 텍스트 패턴을 찾습니다.

  - 리터럴 문자는 정규식 구문에서 특별 한 의미가 없는 문자입니다. 대신 해당 문자를 검색 합니다. 예를 들어 문자와 숫자는 리터럴 문자.

  - Meta 문자는 정규식 구문에서 특별 한 의미 (연산자 또는 구분 기호)를 사용 하는 기호입니다.

    허용 되는 메타 문자는 다음과 같습니다.

    | Meta 문자 | 값 |
    | -------------- | ----- |
    | `.` | **와일드 카드** -임의의 문자 |
    | `*` | 이전 문자 또는 클래스를 0 번 이상 **반복** 합니다. |
    | `^` | **시작 줄 위치** -줄의 시작입니다. |
    | `$` | 줄의 끝 **줄** 끝입니다. |
    | `[class]` | **문자 클래스** -집합에 있는 한 문자 |
    | `[^class]` | **역 클래스** -집합에 없는 한 문자 |
    | `[x-y]` | **Range** -지정 된 범위 내의 모든 문자입니다. |
    | `\x` | 메타 문자를 **이스케이프** 리터럴로 사용 합니다. |
    | `<string` | 단어의 **시작 부분** -단어의 시작입니다. |
    | `string>` | 단어의 끝 **단어** 끝입니다. |

    정규식 구문에 특수 문자 력이 가장 함께 사용 하는 경우. 예를 들어 와일드 카드 문자 ( `.` )와 repeat () 문자의 조합을 사용 `*` 하 여 문자 문자열을 일치 시킵니다.`.*`

    *B* *로 시작 하 고 작업으로*끝나는 모든 문자열을 일치 시키려면 다음 식을 큰 식의 일부로 사용 합니다.`b.*ing`

- 파일 집합에서 여러 문자열을 검색 하려면 별도의 줄에 각 검색 조건을 포함 하는 텍스트 파일을 만들어야 합니다.

- 인수는 접두사로 붙습니다 하지 않는 한 여러 개의 검색 문자열을 구분 하 공간을 사용 하 여 **/c**합니다.

### <a name="examples"></a>예

*Hello* *또는 file* *x. y*에서 검색 하려면 다음을 입력 합니다.

```
findstr hello there x.y
```

File *x. y*에서 *hello* 를 검색 하려면 다음을 입력 합니다.

```
findstr /c:hello there x.y
```

파일 제안에서 단어 *창의* 모든 항목 (초기 대문자 W)을 찾으려면 다음을 입력 *합니다*.

```
findstr Windows proposal.txt
```

문자 대/소문자에 관계 없이 현재 디렉터리와 모든 하위 디렉터리에 있는 모든 *파일을 검색*하려면 다음을 입력 합니다.

```
findstr /s /i Windows *.*
```

및 *에 대해* 시작 하 고 0 개 이상의 공백 (컴퓨터 프로그램 루프) 앞에 있는 줄의 모든 항목을 찾으려면 다음을 입력 합니다.

```
findstr /b /n /r /c:^ *FOR *.bas
```

텍스트 파일에서 검색할 정확한 파일을 나열 하려면 파일 *stringlist .txt*에서 검색 조건을 사용 하 여 *filelist*에 나열 된 파일을 검색 한 다음 결과를 파일 결과에 저장 *합니다. 출력*에 결과를 저장 하려면 다음을 입력 합니다.

```
findstr /g:stringlist.txt /f:filelist.txt > results.out
```

대/소문자에 관계 없이 현재 디렉터리와 모든 하위 디렉터리 내에서 word *컴퓨터* 를 포함 하는 모든 파일을 나열 하려면 다음을 입력 합니다.

```
findstr /s /i /m <computer> *.*
```

Word 컴퓨터를 포함 하는 모든 파일 및 comp로 시작 하는 기타 단어를 나열 하려면 다음을 입력 합니다.

```
findstr /s /i /m <comp.* *.*
```

## <a name="additional-references"></a>추가 참조

- [명령줄 구문 키](command-line-syntax-key.md)